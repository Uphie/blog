---
title: 如何求数组中最小的 k 个数？
author: Uphie
date: 2023-02-04 21:13:00 +0800
categories: [技术]
tags: [go,算法,数组,排序,选择排序]
math: true
toc: true
---

# 问题

输入 n 个整数，找出其中最小的 k 个数。
例如，输入 4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是 1、2、3、4。

# 解法

## 排序再截取

最容易想到的方法就是先排序，再截取 k 个数，如：
```go
// Go 1.19.3

func getLeastNumbers(arr []int, k int) []int {
	if len(arr) < k || k < 1 {
		return nil
	}
    // 对 arr 升序排序
	sort2.Ints(arr)
	return arr[:k]
}
```
上述算法中使用了标准库中的排序算法，在 Go 1.19.3 中采用了 pdqsort 这个新型算法（https://github.com/golang/go/issues/50154），比标准库中的原排序实现快2~60倍。

如果要求不能使用标准库排序的话，可以自己实现，较好的时间复杂度为 $$O(nlogn)$$，那么我们可以使用快速排序。
```go
// 获取数组 arr 中 k 个最小的数
func getLeastNumbers(arr []int, k int) []int {
	if len(arr) < k || k < 1 {
		return nil
	}
	sort(&arr, 0, len(arr)-1)
	return arr[:k]
}

// 对数组 arr 中 [l,r] 区间的元素进行排序
func sort(arr *[]int, l, r int) {
	if l >= r {
		return
	}

	i := partition(arr, l, r)
	sort(arr, l, i-1)
	sort(arr, i+1, r)
}

// 获取数组 arr 中 [l,r] 区间查找基准元素，使比基准元素小的在基准元素左侧，比基准元素大的在基准元素右侧，返回基准元素位置
func partition(arr *[]int, l, r int) int {
	i, j := l, r
	for i < j {
		for i < j && (*arr)[j] >= (*arr)[l] {
			j--
		}
		for i < j && (*arr)[i] <= (*arr)[l] {
			i++
		}
		(*arr)[i], (*arr)[j] = (*arr)[j], (*arr)[i]
	}
	(*arr)[i], (*arr)[l] = (*arr)[l], (*arr)[i]
	return i
}
```

## 快速选择思路变形

由于题目要求找出数组中最小的 k 个数，并不要求我们进行完整排序，上面题解中使用 partition 函数时，最 k 小的数为基准数时其左侧都是比它小的，右侧都是比它大的，换句话说，如果找到的基准位置比 k-1小则最 k 小的在其右侧，反之在左侧，这样只要我们找到第 k 小的数的位置即可。

这种方法时间复杂度为 $$O(n)$$。

```go

func getLeastNumbers(arr []int, k int) []int {
	if len(arr) < k || k < 1 {
		return nil
	}
	// 存储结果
	var result = make([]int, k)
	// 区间起始索引
	l := 0
	// 区间结束索引
	r := len(arr) - 1
	pivot := partition(&arr, l, r)
	// 查找 pivot，使 pivot为第 k 小的数
	for pivot != k-1 && l < r {
		if pivot > k-1 {
			r--
		} else {
			l++
		}
		pivot = partition(&arr, l, r)
	}
	// 最终 pivot=k-1
	fmt.Println(pivot)
	// 最小的 k 个数在 [0,pivot] 区间内
	for i := 0; i <= pivot; i++ {
		result[i] = arr[i]
	}
	return result
}


// 获取数组 arr 中 [l,r] 区间查找基准元素，使比基准元素小的在基准元素左侧，比基准元素大的在基准元素右侧，返回基准元素位置
func partition(arr *[]int, l, r int) int {
	i, j := l, r
	for i < j {
		for i < j && (*arr)[j] >= (*arr)[l] {
			j--
		}
		for i < j && (*arr)[i] <= (*arr)[l] {
			i++
		}
		(*arr)[i], (*arr)[j] = (*arr)[j], (*arr)[i]
	}
	(*arr)[i], (*arr)[l] = (*arr)[l], (*arr)[i]
	return i
}

func main() {
	var l = []int{10, 15, 3, 6, 7, 12, 2, 1, 5}
	fmt.Println("original:", l)
    //  [1 2 3 5]
	fmt.Println("result:", getLeastNumbers(l, 4))
}
```

