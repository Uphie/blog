---
title: 思考一下defer的这个问题
author: Uphie
date: 2023-02-19 19:13:00 +0800
categories: [技术]
tags: [go]
math: true
toc: true
---

观察下面代码的输出是什么？

```go
package main

import "fmt"

func t() (data int) {
	defer func() {
		data += 1
	}()
	return 2
}

func main() {
	b := t()
	fmt.Println(b)
}
```

上面两段代码的输出分别是 `3`。

上面的代码其实等价于下面这段代码：

```go
package main

import "fmt"

func t() int {
	var data int = 0
	defer func() {
		data += 1
	}()
	data = 2
	return data
}

func main() {
	b := t()
	fmt.Println(b)
}
```

**函数在 return 的时候不是原子性的**，有两步：
1. 将返回值赋给一个变量；
2. 执行 RET 指令；


**defer 语句就执行在步骤1、2之间。** `defer` 语句修改了返回值 `data`，所以 `data` 是 3。

